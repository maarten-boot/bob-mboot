#! ../bin/bob

# library testing
# Objects

// lets create a new obj and create a initialize method for it
o1 = new Object;
define o1.initialize(arg1, arg2 = 3 , arg3..) {
	// note that the parser enforces the logical order of initialized arguments after un-initialized and dotdot arguments at the end

	this.arg1 = arg1;
	this.arg2 = arg2;
	stdout.Display("you passed ", arg3.size,": arguments for arg3", "\n");
	this.arg3 = nil;
	if( arg3.size != 0) {
		this.arg3 = arg3;
	}
	// even if the arg3 was not specified it wil be a [] (empty vertor) so we can still use it
	this.arg4 = arg3;

	this;
}
define o1.klak() { return this.arg4.size; }

// the current object wil not have any propery variables but it will hev the initialize method
o1.Show();

arg1 = 6;

// so if we now create a new obj based on the current the initialize will get executed
o2 = new o1( arg1, 8, 7,8,9,0);
o2.Show();
// note that although the property variables are inherited the initializer seems not but it is
o22 = new o2(99);
// the initializer gets called with the one mandatory argument
stdout.Display("o22.klak(): ", o22.klak(), "\n");
o22.Show();

// BUG?: show also inherited methods on new derived objects ?
// no see Exists and ExistsLocally

// as we specified a default for arg2 we dont have to use it when creating a new obj
o3 = new o1( arg1);
o3.Show();

// we have o1 -> o2, o3; o2 -> o22 ;; so  o3.Class == o2.Class
stdout.Display("o1: ", o1.Class(), "\n");
stdout.Display("o2: ", o2.Class(), "\n");
stdout.Display("o22: ", o22.Class(), "\n");
stdout.Display("o3: ", o3.Class(), "\n");
stdout.Display(o3.Class() == o2.Class(), "\n");

// lets Clone a o4 from o22
o4 = o22.Clone();
o4.Show();
stdout.Display("o22: ", o22.Class(), "\n");
stdout.Display("o4: ", o4.Class(), "\n");

// they are now of the same Class
stdout.Display(o22.Class() == o4.Class(), "\n");

// we can now modify each object instance individually
o4.arg1 = 100;
o4.Show();
o22.Show();
// o44 = o22.Clone(66); // clone cannot take arguments: runtime error: Error: Too many arguments - <CMethod-Clone>

// for symbol we pass the literal reference as passing arg1 would pass its value not its name
stdout.Display("name of var: ", \arg1, " value of var: ", arg1, "\n");

// Exists looks on the whole inheritance tree all the way to the top
// whereas ExistsLocally only looks at the diret object used and does not go up the tree
// this is why we see the propery values as they are all local instances where as the methods may be up the tree also

p1 = o22.Exists(\arg1);
stdout.Display("does o22 have a arg1: ", p1, "\n");

p1 = o22.ExistsLocally(\arg1);
stdout.Display("does o22 locally have a arg1: ", p1, "\n");

p2 = o22.Exists(\arg5);
stdout.Display("does o22 have a arg5: ", p2, "\n");

p3 = o22.Exists(\initialize);
stdout.Display("does o22 have initialize: ", p3, "\n");

p3 = o22.ExistsLocally(\initialize);
stdout.Display("does o22 have initialize locally: ", p3, "\n");

stdout.Display("does o22 have klak: ", o22.Exists(\klak), "\n");
stdout.Display("does o22 have foo: ", o22.Exists(\foo), "\n");

// not that i have not seen class variables or a way to see if the symbol is a method or a variable

